generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")  // Used for migrations, bypasses connection pooler
}

// ============================================================================
// AUTHENTICATION & USERS
// ============================================================================

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String           @id @default(uuid())
  email               String           @unique
  name                String?
  image               String?
  emailVerified       DateTime?        // Required by NextAuth Prisma Adapter
  role                UserRole         @default(Editor)
  phone               String?
  address             String?
  defaultRestaurantId String?          // User's preferred/default restaurant
  defaultRestaurant   Restaurant?      @relation("DefaultRestaurant", fields: [defaultRestaurantId], references: [id])
  restaurants         UserRestaurant[] // Restaurants this user can access
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  accounts            Account[]
  sessions            Session[]
  notificationPreference NotificationPreference?
}

// Junction table for User <-> Restaurant (many-to-many)
model UserRestaurant {
  id           String     @id @default(uuid())
  userId       String
  restaurantId String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@unique([userId, restaurantId])
  @@index([userId])
  @@index([restaurantId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  Editor
  Manager
}

enum RestaurantType {
  Bakery
  Cafe
  Restaurant
  FastFood
}

// ============================================================================
// RESTAURANT (Multi-location support)
// ============================================================================

model Restaurant {
  id                   String           @id @default(uuid())
  name                 String
  restaurantType       RestaurantType   @default(Bakery)
  inventoryEnabled     Boolean          @default(true)
  productionEnabled    Boolean          @default(true)
  location             String?          // e.g., "Conakry - Centre", "Conakry - Kaloum"
  openingDate          DateTime?
  initialCapital       Float            @default(0)
  initialCashBalance   Float            @default(0)
  initialOrangeBalance Float            @default(0)
  initialCardBalance   Float            @default(0)
  contactPhone         String?
  contactEmail         String?
  managerName          String?
  currency             String           @default("GNF")
  trackingStartDate    DateTime?
  stockDeductionMode   String           @default("immediate") // "immediate" | "deferred"
  isActive             Boolean          @default(true)
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Relations
  users                UserRestaurant[]
  defaultForUsers      User[]           @relation("DefaultRestaurant")
  inventoryItems       InventoryItem[]
  stockMovements       StockMovement[]
  productionLogs       ProductionLog[]
  products             Product[]        // Product catalog for production
  sales                Sale[]
  expenses             Expense[]
  cashDeposits         CashDeposit[]    // Deprecated: use bankTransactions
  bankTransactions     BankTransaction[]
  dailySummaries       DailySummary[]
  paymentMethods       PaymentMethod[]
  notificationLogs     NotificationLog[]
  customers            Customer[]
  debts                Debt[]
  debtPayments         DebtPayment[]

  @@index([isActive])
  @@index([restaurantType])
}

// ============================================================================
// INVENTORY MANAGEMENT
// ============================================================================

model InventoryItem {
  id             String          @id @default(uuid())
  restaurantId   String
  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id])
  name           String
  nameFr         String?
  category       String
  unit           String
  currentStock   Float           @default(0)
  minStock       Float           @default(0)
  reorderPoint   Float           @default(0)
  unitCostGNF    Float           @default(0)
  supplierId     String?
  supplier       Supplier?       @relation(fields: [supplierId], references: [id])
  expiryDays     Int?
  isActive       Boolean         @default(true)
  stockMovements StockMovement[]
  expenseItems   ExpenseItem[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([restaurantId])
  @@index([category])
  @@index([supplierId])
  @@index([isActive])
}

model StockMovement {
  id              String         @id @default(uuid())
  restaurantId    String
  restaurant      Restaurant     @relation(fields: [restaurantId], references: [id])
  itemId          String
  item            InventoryItem  @relation(fields: [itemId], references: [id])
  type            MovementType
  quantity        Float
  unitCost        Float?
  reason          String?
  productionLogId String?
  productionLog   ProductionLog? @relation(fields: [productionLogId], references: [id])
  expenseId       String?
  expense         Expense?       @relation(fields: [expenseId], references: [id])
  createdBy       String
  createdByName   String?
  createdAt       DateTime       @default(now())

  @@index([restaurantId])
  @@index([itemId])
  @@index([type])
  @@index([createdAt])
  @@index([itemId, createdAt])
  @@index([restaurantId, type, createdAt])
}

enum MovementType {
  Purchase
  Usage
  Waste
  Adjustment
}

// ============================================================================
// PRODUCTION TRACKING
// ============================================================================

model ProductionLog {
  id                  String            @id @default(uuid())
  restaurantId        String
  restaurant          Restaurant        @relation(fields: [restaurantId], references: [id])
  date                DateTime
  productionType      ProductCategory?  // Patisserie or Boulangerie
  productName         String            // Legacy: single product name (kept for backward compatibility)
  productNameFr       String?
  quantity            Int               // Legacy: single product quantity
  ingredients         Json              // Basic recipe ingredients list
  ingredientDetails   Json?             // Detailed breakdown: [{itemId, itemName, plannedQty, actualQty, unit}]
  estimatedCostGNF    Float?            // Calculated cost from ingredients
  preparationStatus   ProductionStatus  @default(Planning)
  notes               String?
  status              SubmissionStatus  @default(Pending)
  stockDeducted       Boolean           @default(false)   // Whether stock has been deducted
  stockDeductedAt     DateTime?                           // When stock was deducted
  createdBy           String
  createdByName       String?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  stockMovements      StockMovement[]
  productionItems     ProductionItem[]  // Multi-product support

  @@index([restaurantId])
  @@index([date])
  @@index([status])
  @@index([preparationStatus])
  @@index([productionType])
}

enum ProductionStatus {
  Planning    // Production is being planned
  Complete    // Production finished
}

enum ProductCategory {
  Patisserie  // Pastry products (croissants, pain au chocolat, etc.)
  Boulangerie // Bread products (baguettes, etc.)
}

// Product catalog for production tracking
model Product {
  id             String          @id @default(uuid())
  restaurantId   String
  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  name           String
  nameFr         String?
  category       ProductCategory
  unit           String          @default("piece") // piece, loaf, dozen
  standardRecipe Json?           // [{ itemId, quantity, unit }]
  isActive       Boolean         @default(true)
  sortOrder      Int             @default(0)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  productionItems ProductionItem[]
  saleItems       SaleItem[]      // Products sold in sales

  @@index([restaurantId])
  @@index([category])
  @@index([isActive])
  @@index([restaurantId, category, isActive])
}

// Junction table for ProductionLog <-> Product (multi-product production)
model ProductionItem {
  id              String        @id @default(uuid())
  productionLogId String
  productionLog   ProductionLog @relation(fields: [productionLogId], references: [id], onDelete: Cascade)
  productId       String
  product         Product       @relation(fields: [productId], references: [id])
  quantity        Int

  @@index([productionLogId])
  @@index([productId])
}

// ============================================================================
// SALES TRACKING
// ============================================================================

model Sale {
  id                 String           @id @default(uuid())
  restaurantId       String
  restaurant         Restaurant       @relation(fields: [restaurantId], references: [id])
  date               DateTime
  totalGNF           Float
  totalEUR           Float            @default(0)
  cashGNF            Float            @default(0)
  orangeMoneyGNF     Float            @default(0)
  cardGNF            Float            @default(0)
  itemsCount         Int?
  customersCount     Int?
  receiptUrl         String?
  openingTime        String?
  closingTime        String?
  comments           String?
  status             SubmissionStatus @default(Pending)
  submittedBy        String?
  submittedByName    String?
  approvedBy         String?
  approvedByName     String?
  approvedAt         DateTime?
  lastModifiedBy     String?
  lastModifiedByName String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  cashDeposit        CashDeposit?     // Deprecated: use bankTransaction
  bankTransaction    BankTransaction? @relation("BankTransactionSale")
  debts              Debt[]
  saleItems          SaleItem[]       // Optional product breakdown

  @@unique([restaurantId, date]) // One sale per restaurant per day
  @@index([restaurantId])
  @@index([date])
  @@index([status])
}

// Junction table for Sale <-> Product (optional product sales tracking)
model SaleItem {
  id            String   @id @default(uuid())
  saleId        String
  sale          Sale     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  productId     String?  // Optional: links to Product catalog
  product       Product? @relation(fields: [productId], references: [id])

  // Manual entry (if product not in catalog)
  productName   String?
  productNameFr String?

  quantity      Int
  unitPrice     Float?   // Optional: unit price per item

  createdAt     DateTime @default(now())

  @@index([saleId])
  @@index([productId])
}

enum SubmissionStatus {
  Pending
  Approved
  Rejected
}

// ============================================================================
// CUSTOMER & DEBT MANAGEMENT
// ============================================================================

model Customer {
  id             String          @id @default(uuid())
  restaurantId   String
  restaurant     Restaurant      @relation(fields: [restaurantId], references: [id])
  name           String
  phone          String?
  email          String?
  address        String?
  company        String?
  customerType   CustomerType    @default(Individual)
  creditLimit    Float?
  notes          String?
  isActive       Boolean         @default(true)
  debts          Debt[]
  debtPayments   DebtPayment[]
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  @@index([restaurantId])
  @@index([restaurantId, isActive])
  @@index([restaurantId, name])
}

enum CustomerType {
  Individual
  Corporate
  Wholesale
}

model Debt {
  id                String        @id @default(uuid())
  restaurantId      String
  restaurant        Restaurant    @relation(fields: [restaurantId], references: [id])
  saleId            String?
  sale              Sale?         @relation(fields: [saleId], references: [id])
  customerId        String
  customer          Customer      @relation(fields: [customerId], references: [id])

  principalAmount   Float
  paidAmount        Float         @default(0)
  remainingAmount   Float

  dueDate           DateTime?
  status            DebtStatus    @default(Outstanding)

  description       String?
  notes             String?

  createdBy         String
  createdByName     String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  payments          DebtPayment[]

  @@index([restaurantId])
  @@index([saleId])
  @@index([customerId])
  @@index([status])
  @@index([dueDate])
  @@index([restaurantId, status])
}

enum DebtStatus {
  Outstanding
  PartiallyPaid
  FullyPaid
  Overdue
  WrittenOff
}

model DebtPayment {
  id              String        @id @default(uuid())
  restaurantId    String
  restaurant      Restaurant    @relation(fields: [restaurantId], references: [id])
  debtId          String
  debt            Debt          @relation(fields: [debtId], references: [id], onDelete: Cascade)
  customerId      String
  customer        Customer      @relation(fields: [customerId], references: [id])

  amount          Float
  paymentMethod   String
  paymentDate     DateTime

  receiptNumber   String?
  notes           String?

  receivedBy      String
  receivedByName  String?
  createdAt       DateTime      @default(now())

  // Link to bank transaction (for DebtCollection deposits)
  bankTransaction BankTransaction?

  @@index([restaurantId])
  @@index([debtId])
  @@index([customerId])
  @@index([paymentDate])
}

// ============================================================================
// EXPENSE MANAGEMENT
// ============================================================================

model Expense {
  id                  String           @id @default(uuid())
  restaurantId        String
  restaurant          Restaurant       @relation(fields: [restaurantId], references: [id])
  date                DateTime
  categoryId          String?
  category            Category?        @relation(fields: [categoryId], references: [id])
  categoryName        String
  amountGNF           Float
  amountEUR           Float            @default(0)
  paymentMethod       String           // Payment method name (instead of enum)
  description         String?
  receiptUrl          String?
  comments            String?
  transactionRef      String?
  status              SubmissionStatus @default(Pending)
  submittedBy         String?
  submittedByName     String?
  approvedBy          String?
  approvedByName      String?
  approvedAt          DateTime?
  lastModifiedBy      String?
  lastModifiedByName  String?
  lastModifiedAt      DateTime?
  supplierId          String?
  supplier            Supplier?        @relation(fields: [supplierId], references: [id])
  isInventoryPurchase Boolean          @default(false)
  stockMovements      StockMovement[]
  expenseItems        ExpenseItem[]
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  // Payment tracking (supports partial payments)
  paymentStatus       PaymentStatus    @default(Unpaid)
  totalPaidAmount     Float            @default(0)  // Sum of all payments
  fullyPaidAt         DateTime?        // When fully paid

  // Relation to payment records (multiple payments allowed)
  expensePayments     ExpensePayment[]

  @@index([restaurantId])
  @@index([date])
  @@index([status])
  @@index([categoryId])
  @@index([supplierId])
  @@index([paymentStatus])
}

// Junction table for Expense <-> InventoryItem (many-to-many for inventory purchases)
model ExpenseItem {
  id              String        @id @default(uuid())
  expenseId       String
  expense         Expense       @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id])
  quantity        Float
  unitCostGNF     Float

  @@index([expenseId])
  @@index([inventoryItemId])
}

// Payment methods are now configurable per restaurant
model PaymentMethod {
  id           String     @id @default(uuid())
  restaurantId String
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  name         String     // "Cash", "Orange Money", "Card", etc.
  nameFr       String?    // French translation
  type         String     // "cash", "mobile_money", "card", "bank_transfer"
  icon         String     @default("Wallet") // Lucide icon name
  color        String     @default("#C45C26")
  isActive     Boolean    @default(true)
  sortOrder    Int        @default(0)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([restaurantId, name])
  @@index([restaurantId, isActive])
}

// ============================================================================
// CATEGORIES & SUPPLIERS (Shared across restaurants)
// ============================================================================

model Category {
  id             String             @id @default(uuid())
  name           String             @unique
  nameFr         String?
  color          String?
  expenseGroupId String?
  expenseGroup   ExpenseGroup?      @relation(fields: [expenseGroupId], references: [id])
  suppliers      CategorySupplier[]
  expenses       Expense[]
  isActive       Boolean            @default(true)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
}

model ExpenseGroup {
  id         String     @id @default(uuid())
  key        String     @unique
  label      String
  labelFr    String?
  icon       String
  color      String
  sortOrder  Int        @default(0)
  isActive   Boolean    @default(true)
  categories Category[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
}

model Supplier {
  id             String             @id @default(uuid())
  name           String             @unique
  phone          String?
  email          String?
  address        String?
  paymentTerms   String?
  isActive       Boolean            @default(true)
  expenses       Expense[]
  categories     CategorySupplier[]
  inventoryItems InventoryItem[]
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
}

model CategorySupplier {
  id         String   @id @default(uuid())
  categoryId String
  supplierId String
  category   Category @relation(fields: [categoryId], references: [id])
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  @@unique([categoryId, supplierId])
}

// ============================================================================
// CASH DEPOSITS
// ============================================================================

model CashDeposit {
  id              String            @id @default(uuid())
  restaurantId    String
  restaurant      Restaurant        @relation(fields: [restaurantId], references: [id])
  date            DateTime
  amount          Float
  status          CashDepositStatus @default(Pending)
  bankRef         String?
  receiptUrl      String?
  comments        String?
  depositedBy     String?
  depositedByName String?
  depositedAt     DateTime?
  saleId          String?           @unique
  sale            Sale?             @relation(fields: [saleId], references: [id])
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([restaurantId])
  @@index([date])
  @@index([status])
}

enum CashDepositStatus {
  Pending
  Deposited
}

// ============================================================================
// BANK TRANSACTIONS (Replaces CashDeposit for comprehensive tracking)
// ============================================================================

model BankTransaction {
  id              String                  @id @default(uuid())
  restaurantId    String
  restaurant      Restaurant              @relation(fields: [restaurantId], references: [id])

  // Transaction details
  date            DateTime
  amount          Float                   // Always positive
  type            BankTransactionType     // Deposit | Withdrawal
  method          BankPaymentMethod       // Cash | OrangeMoney | Card

  // Categorization
  reason          TransactionReason       // SalesDeposit | DebtCollection | ExpensePayment | OwnerWithdrawal | CapitalInjection | Other
  description     String?

  // Status tracking
  status          BankTransactionStatus   @default(Pending)
  confirmedAt     DateTime?
  bankRef         String?                 // Bank reference number
  receiptUrl      String?

  // Links to source records (optional, mutually exclusive)
  saleId          String?                 @unique // For SalesDeposit
  sale            Sale?                   @relation("BankTransactionSale", fields: [saleId], references: [id])
  debtPaymentId   String?                 @unique // For DebtCollection
  debtPayment     DebtPayment?            @relation(fields: [debtPaymentId], references: [id])

  // Back-reference from ExpensePayment (for ExpensePayment reason)
  expensePayment  ExpensePayment?

  // Audit
  createdBy       String?
  createdByName   String?
  comments        String?
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt

  @@index([restaurantId])
  @@index([date])
  @@index([type])
  @@index([status])
  @@index([reason])
  @@index([method])
}

enum BankTransactionType {
  Deposit
  Withdrawal
}

enum BankPaymentMethod {
  Cash
  OrangeMoney
  Card
}

enum TransactionReason {
  SalesDeposit      // Cash from daily sales deposited
  DebtCollection    // Customer paid off debt
  ExpensePayment    // Withdrew cash to pay supplier
  OwnerWithdrawal   // Owner took money out
  CapitalInjection  // Owner added money
  Other             // Miscellaneous
}

enum BankTransactionStatus {
  Pending           // Created but not confirmed
  Confirmed         // Verified/completed
}

// ============================================================================
// EXPENSE PAYMENTS (Track individual payments against an expense)
// ============================================================================

model ExpensePayment {
  id                  String              @id @default(uuid())
  expenseId           String
  expense             Expense             @relation(fields: [expenseId], references: [id])

  // Payment details
  amount              Float               // Amount paid in this installment
  paymentMethod       BankPaymentMethod   // Cash | OrangeMoney | Card
  paidAt              DateTime            @default(now())

  // Link to bank transaction (for withdrawal tracking)
  bankTransactionId   String?             @unique
  bankTransaction     BankTransaction?    @relation(fields: [bankTransactionId], references: [id])

  // Transaction reference (for Card/OrangeMoney payments)
  transactionId       String?             // External transaction reference from payment processor

  // Audit
  paidBy              String?
  paidByName          String?
  notes               String?
  receiptUrl          String?
  createdAt           DateTime            @default(now())

  @@index([expenseId])
  @@index([paidAt])
}

enum PaymentStatus {
  Unpaid              // totalPaidAmount = 0
  PartiallyPaid       // 0 < totalPaidAmount < amountGNF
  Paid                // totalPaidAmount >= amountGNF
}

// ============================================================================
// DAILY SUMMARY (Per Restaurant)
// ============================================================================

model DailySummary {
  id                      String     @id @default(uuid())
  restaurantId            String
  restaurant              Restaurant @relation(fields: [restaurantId], references: [id])
  date                    DateTime
  dailyCashSales          Float      @default(0)
  dailyOrangeSales        Float      @default(0)
  dailyCardSales          Float      @default(0)
  dailyCashExpenses       Float      @default(0)
  dailyOrangeExpenses     Float      @default(0)
  dailyCardExpenses       Float      @default(0)
  cumulativeCashBalance   Float      @default(0)
  cumulativeOrangeBalance Float      @default(0)
  cumulativeCardBalance   Float      @default(0)
  lowStockItemsCount      Int        @default(0)
  criticalStockItemsCount Int        @default(0)
  totalInventoryValueGNF  Float      @default(0)
  createdAt               DateTime   @default(now())
  updatedAt               DateTime   @updatedAt

  @@unique([restaurantId, date]) // One summary per restaurant per day
  @@index([restaurantId])
  @@index([date])
}

// ============================================================================
// NOTIFICATION PREFERENCES & LOGS
// ============================================================================

model NotificationPreference {
  id                    String   @id @default(uuid())
  userId                String
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Notification toggles
  lowStockAlerts        Boolean  @default(true)
  criticalStockAlerts   Boolean  @default(true)
  expenseAlerts         Boolean  @default(true)
  approvalAlerts        Boolean  @default(true)
  dailySummary          Boolean  @default(true)
  expiryAlerts          Boolean  @default(true)

  // Thresholds
  largeExpenseThreshold Float?   @default(500000) // GNF threshold for alerts
  expiryWarningDays     Int      @default(7)      // Days before expiry to trigger alerts

  // Preferences
  preferredLocale       String   @default("fr") // 'fr' | 'en'
  quietHoursStart       String?  // e.g., "22:00"
  quietHoursEnd         String?  // e.g., "07:00"

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@unique([userId])
}

model NotificationLog {
  id            String     @id @default(uuid())
  restaurantId  String
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id])
  recipientPhone String
  messageType   String     // 'low_stock', 'expense_approved', etc.
  message       String
  status        String     // 'sent', 'failed', 'delivered'
  providerMsgId String?    // Twilio message SID
  errorMessage  String?
  sentAt        DateTime   @default(now())
  deliveredAt   DateTime?

  @@index([restaurantId])
  @@index([sentAt])
  @@index([status])
}
